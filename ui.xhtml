<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright (©) 2011  Andrzej Zaborowski
     usage is allowed under the terms of the GNU AGPLv3 -->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Wyszukiwarka drzew analizy w NKJP</title>
<script type="application/javascript" src="www/viewer.js" />
<script type="application/javascript" src="www/viewer_helpers.js" />
<link type="text/css" rel="stylesheet" href="www/viewer.css" />
</head>
<body id="body">
 <div id="searchdiv">
  <div class="searchinput">
   <input class="searchinput" id="searchinput" />
  </div>
 </div>
 <div id="resultdiv">
  <div id="res_list" />
  <div id="res_forest"><div id="res_dpy" /></div>
  <div id="helpdiv"><div>
   <p>FIXME Tu powinny znaleść się informacje o języku zapytań</p>
   <p>FIXME i o korpusie?</p>
   <p>Bardziej kompletny opis języka zapytań TIGERSearch znajduje się
    w instrukcji do wyszukiwarki TIGERSearch (<a href='http://www.ims.uni-stuttgart.de/projekte/TIGER/TIGERSearch/manual_html.html'>HTML</a>,
    <a href='http://www.ims.uni-stuttgart.de/projekte/TIGER/TIGERSearch/doc/pdf/manual.pdf'>PDF</a>,
    rozdział III), a jego pełna formalna specyfikacja dostępna jest
    w:<ul><li>
    König, Esther and Lezius, Wolfgang (2003): <i>The TIGER language -
    Chapter VII - Appendix A - Description Language for Syntax Graphs.
    Formal Definition.</i> Technical report, IMS, University of Stuttgart.
   </li></ul></p>
  </div></div>
 </div>
 <script type="application/javascript"><![CDATA[
document.create_button = function(parent, id) {
	var btn = document.createElement("div");

	btn.className = "button";
	btn.id = id;
	parent.appendChild(btn);

	watchable(btn);

	btn.text = "";
	btn.watch("text", function(prop, oldval, newval) {
				return btn.innerHTML = newval;
			});

	btn.enabled = true;
	btn.watch("enabled", function(prop, oldval, newval) {
				btn.className = btn.visible ? newval ?
					"button" : "button disabled" :
					"invisible";
				return newval;
			});

	btn.visible = true;
	btn.watch("visible", function(prop, oldval, newval) {
				btn.className = newval ? btn.enabled ?
					"button disabled" : "button" :
					"invisible";
				return newval;
			});

	return btn;
}

function attach_text_listener(input, func) {
	if (window.addEventListener)
		input.addEventListener('input', func, false);
	else
		input.attachEvent('onpropertychange',
				function() { func.call(input); });
}

var searched = true;
var textinput = document.getElementById('searchinput');
var searchdiv = document.getElementById('searchdiv');
var res_list = document.getElementById('res_list');
var res_forest = document.getElementById('res_forest');
var help = document.getElementById('helpdiv');
var searchbutton = document.create_button(searchdiv, 'searchbutton');
var helpbutton = document.create_button(searchdiv, 'helpbutton');
res_forest.dpy = document.getElementById('res_dpy');
res_forest.closebutton = document.create_button(res_forest, 'closebutton');
res_forest.nextbutton = document.create_button(res_forest, 'nextbutton');
res_forest.prevbutton = document.create_button(res_forest, 'prevbutton');

textinput.onchange = function(evt) {
	if (!searched)
		return;
	searched = false;
	searchbutton.enabled = true;
}
textinput.onkeydown = function(evt) {
	if (evt.keyCode == 13)
		searchbutton.onclick(evt);
}
searchbutton.innerHTML = 'Szukaj';
searchbutton.enabled = false;
attach_text_listener(textinput, textinput.onchange);

res_list.search_sn = 0;
res_list.query = '';
searchbutton.onclick = function(evt) {
	if (!searchbutton.enabled)
		return;

	/* Disable the button */
	searched = true;
	searchbutton.enabled = false;

	/* Clear old search results */
	switch_to(res_list);
	res_list.set_message(wait);
	res_list.search_sn ++;

	/* Send the query */
	if (textinput.value.length < 1) {
		res_list.innerHTML = '';
		return;
	}

	res_list.query = textinput.value.replace(/#/g, '%23');
	res_list.offset = 0;
	res_list.res_count = -1;
	res_list.send_query();
}

res_list.send_query = function() {
	var query = this.offset ?
		'/searchat/' + this.offset + '/' + this.query :
		('/search/' + this.query);
	request_send(query, function(resp) {
			if (typeof(resp) != 'object') {
				res_list.set_message('Serwer twierdzi: ' +
						resp.to_xml_safe());
				return;
			}

			if (res_list.res_count == -1) {
				if (resp.hits.length >= 20)
					res_list.send_count_query();
				else
					res_list.res_count = resp.hits.length;
			}
			res_list.fill(resp.hits);
		}, function(resp) {
			res_list.set_message('Błąd połączenia: ' + resp);
		}, false);
}

res_list.send_count_query = function() {
	if (res_list.res_count != -1)
		return;
	res_list.res_count = -2;

	var query = '/searchcount/' + this.query;
	request_send(query, function(resp) {
			if (typeof(resp) != 'object')
				res_list.res_count = -3;
			else
				res_list.res_count = resp.count;
			res_list.update_status();
		}, function(resp) {
			res_list.res_count = -3;
			res_list.update_status();
		}, false);
}

res_forest.closebutton.style.zIndex = 1000;
res_forest.closebutton.innerHTML = 'Zamknij';
res_forest.closebutton.onclick = function(evt) {
	switch_to(res_list);
}
res_forest.nextbutton.style.zIndex = 1000;
res_forest.nextbutton.innerHTML = '&gt;';
res_forest.prevbutton.style.zIndex = 1000;
res_forest.prevbutton.innerHTML = '&lt;';

helpbutton.innerHTML = '?';
helpbutton.enabled = true;
helpbutton.onclick = function(evt) {
	if (!('opstate' in help) || help.opstate < 50)
		switch_to(help, [ res_list, res_forest ]);
	else {
		var dest = null;
		if (res_forest.opstate > 50)
			dest = res_forest;
		else if (res_list.opstate > 50)
			dest = res_list;
		switch_to(dest, [ res_list, res_forest ]);
	}
}

res_list.dest_left = 2;
res_list.dest_right = 15;
res_list.dest_top = 2;
res_list.dest_bottom = 2;
res_forest.dest_left = 15;
res_forest.dest_right = 2;
res_forest.dest_top = 2;
res_forest.dest_bottom = 2;
help.dest_left = 12;
help.dest_right = 12;
help.dest_top = 15;
help.dest_bottom = 15;

var anim_tmr = null;
var elems = [ res_list, res_forest, help ];
function switch_to(elem, nofadeelems) {
	for (var i in elems) {
		if (!('opstate' in elems[i]))
			elems[i].opstate = 0;
		elems[i].start_opstate = elems[i].opstate;
		if (elems[i] === elem)
			elems[i].dest_opstate = 100;
		else if (nofadeelems != undefined &&
				nofadeelems.indexOf(elems[i]) > -1 &&
				elems[i].opstate >= 60)
			elems[i].dest_opstate = 60;
		else
			elems[i].dest_opstate = 0;
		elems[i].animstep =
			elems[i].dest_opstate == elems[i].start_opstate ?
			100 : 0;

		if (elems[i].dest_opstate > 0 || elems[i].start_opstate > 0) {
			elems[i].style.left = elems[i].dest_left + "%";
			elems[i].style.right = elems[i].dest_right + "%";
			elems[i].style.top = elems[i].dest_top + "%";
			elems[i].style.bottom = elems[i].dest_bottom + "%";
		}
	}

	if (anim_tmr)
		clearTimeout(anim_tmr);

	var update = function(evt) {
		var updated = 0;
		for (var i in elems) {
			var el = elems[i];
			if (el.animstep >= 100)
				continue;
			el.animstep += 10;

			updated ++;
			el.opstate = el.animstep / 100 *
				(el.dest_opstate - el.start_opstate) +
				el.start_opstate;
			var p = Math.sin(el.animstep * 0.0314 - 1.57) * .5 + .5;
			p = p * (el.dest_opstate - el.start_opstate) +
				el.start_opstate;
			p = 0.8 + p / 500;

			el.style[prop] = el.opstate < 99.9 ?
				'scale(' + p + ')' : '';
			el.style.opacity = 0.01 * el.opstate;
			el.style.zIndex = Math.round(el.opstate);
			el.style.visibility = el.opstate > 0.1 ?
				'visible' : 'hidden';
		}
		if (updated)
			anim_tmr = setTimeout(update, 20);
	}
	update(null);
}

var prop, props = [ 'transform', 'WebkitTransform', 'msTransform',
	'MozTransform', 'OTransform' ];
while (prop = props.shift())
	if (prop in res_list.style)
		break;

res_list.fill = function(results) {
	if (!results.length)
		return this.set_message('Brak trafień');

	var table = document.createElement('table');
	table.id = 'res-table';
	for (var i = 0; i < results.length; i ++) {
		var res = results[i];
		var row = table.insertRow(-1);
		var cell = row.insertCell(-1);
		var t0 = '' + res.nodes.length + ' ' + [ 'trafienie',
			'trafienia', 'trafień' ][pl_plural(res.nodes.length)];
		var t1 = res.path;

		res.cell = cell;
		t0 = '<span class="hint">' + t0 + '</span>';

		cell.className = 'res' + (i & 1);
		cell.orig = [ t0, t1 ];
		cell.innerHTML = t0 + t1;
	}

	/* TODO: we currently hide the old results and wait for new ones
	 * and then display only those when they're ready.  We could do
	 * something more interesting like appending the new results to the
	 * current list or something else.  One problem though is that we
	 * should drop the XML docs for those old results because they take
	 * a lot of memory..
	 */
	if (results.length == 20 && !('nextlink' in this)) {
		this.nextlink = document.createElement('tr');
		this.nextlink.className = 'status';
		var cell = this.nextlink.insertCell(-1);
		cell.className = 'res2';
		cell.innerHTML = '<a href="#">Pobierz następne dwadzieścia</a>';
		cell.onclick = function(evt) {
			/* Clear old search results */
			switch_to(res_list);
			res_list.set_message(wait);
			res_list.search_sn ++;

			res_list.offset += 20;
			res_list.send_query();
		};
	}

	if (!('statusrow' in this)) {
		this.statusrow = document.createElement('tr');
		this.statusrow.className = 'status';
		var cell = this.statusrow.insertCell(-1);
		cell.className = 'res2';
	}

	if (this.offset && !('prevlink' in this)) {
		this.prevlink = document.createElement('tr');
		this.prevlink.className = 'status';
		var cell = this.prevlink.insertCell(-1);
		cell.className = 'res2';
		cell.innerHTML =
			'<a href="#">Pobierz poprzednie dwadzieścia</a>';
		cell.onclick = function(evt) {
			/* Clear old search results */
			switch_to(res_list);
			res_list.set_message(wait);
			res_list.search_sn ++;

			res_list.offset -= 20;
			res_list.send_query();
		};
	}

	this.res_table = table;
	this.results = results;
	this.update_status();

	this.innerHTML = '';
	this.appendChild(table);

	this.tree_xml_load(0);
}

res_list.update_status = function() {
	var showprev = this.offset > 0;
	var shownext = (this.res_count < 0 && this.results.length == 20) ||
		this.offset + 20 < this.res_count;

	if (this.statusrow.parentNode)
		this.statusrow.parentNode.removeChild(this.statusrow);
	if ('prevlink' in this && this.prevlink.parentNode)
		this.prevlink.parentNode.removeChild(this.prevlink);
	if ('nextlink' in this && this.nextlink.parentNode)
		this.nextlink.parentNode.removeChild(this.nextlink);

	var ze = '' + this.res_count;
	ze = ((ze.length % 3) == 0 && ze[0] == '1') ? ' ze ' : ' z ';
	if ((this.offset == 0 && this.results.length < 20) ||
			this.res_count == 20)
		this.statusrow.innerHTML = 'Znaleziono ' + this.results.length +
			[ ' zdanie', ' zdania', ' zdań' ]
				[pl_plural(this.results.length)];
	else
		this.statusrow.innerHTML = 'Pokazano zdania od ' +
			(this.offset + 1) + ' do ' +
			(this.offset + this.results.length) + ze +
			(this.res_count == -2 ? wait_small :
			 (this.res_count < 0 ? '<img src=\'www/cross.png\' ' +
			  'alt=\'Błąd zapytania\' title=\'Błąd zapytania\' />' :
			  '' + this.res_count + ' pasujących'));

	if (!this.statusrow.parentNode)
		this.res_table.appendChild(this.statusrow);
	if (shownext)
		this.res_table.appendChild(this.nextlink);
	if (showprev)
		this.res_table.appendChild(this.prevlink);
}

res_list.tree_xml_load = function(i) {
	if (i >= this.results.length)
		return;

	var sn = this.search_sn;
	var res = this.results[i];
	res.cell.innerHTML = wait_small + res.cell.orig[0] + res.cell.orig[1];

	var this_obj = this;
	function next() {
		/* Hope this doesn't leave context references behind */
		setTimeout(function() { this_obj.tree_xml_load(i + 1); }, 50 );
	}

	request_send(res.path, function(resp) {
			if (sn != this_obj.search_sn)
				return;
			try {
				res.data = adapt_schema(resp);
			} catch(e) {
				this_obj.set_message(e);
				return;
			}

			var icons = '';
			if (resp.forest['answer-data']['base-answer'].type ==
					'NO_TREE') {
				icons += '<img src=\'www/cross.png\' alt=\'' +
					'Las nie zawiera poprawnego drzewa ' +
					'analizy\' title=\'' +
					'Las nie zawiera poprawnego drzewa ' +
					'analizy\' class=\'icon\' />';
				res.data.nodes[res.data.root].chosen = false;
			}
			icons += '<img src=\'www/spreadsheet.png\' alt=\'' +
				'Pokaż arkusz syntaktyczny dla tego lasu ' +
				'analizy\' title=\'' +
				'Pokaż arkusz syntaktyczny dla tego lasu ' +
				'analizy\' class=\'icon\' onclick=\'' +
				'ss_show(event, ' + i + ');\' />';

			var minfrom = 11111, maxto = 0;
			for (var j in res.nodes[0]) {
				var n = res.data.nodes[res.nodes[0][j]];
				if (res.data.frompos[n.from] < minfrom)
					minfrom = res.data.frompos[n.from];
				if (res.data.topos[n.to] > maxto)
					maxto = res.data.topos[n.to];
			}
			var text = '';
			var start = 0;
			if (minfrom > 14 && maxto > 40) {
				text += '...';
				start = minfrom - 11;
			}
			text += res.data.text.substring(start,
					minfrom).to_xml_safe();
			text += '<span class="hilite">';
			text += res.data.text.substring(minfrom,
					maxto).to_xml_safe();
			text += '</span>';
			text += res.data.text.substring(maxto,
					res.data.text.length).to_xml_safe();

			res.cell.orig[1] = text;
			res.cell.orig[2] = icons;
			res.cell.innerHTML = res.cell.orig[0] +
				res.cell.orig[2] + res.cell.orig[1];

			res.cell.num = i;
			res.cell.onclick = tree_show;
			//res.cell.getElementsByClassName('ssopen')[0].num = i;
			//res.cell.getElementsByClassName('ssopen')[0].onclick =
			//	ss_show;

			next();
		}, function(resp) {
			if (sn != this_obj.search_sn)
				return;
			/* TODO: add a red cross icon */
			res.cell.innerHTML = res.cell.orig[0] +
				res.cell.orig[1];

			next();
		}, true);
}

function tree_show(evt) {
	var res = res_list.results[this.num];

	switch_to(res_forest, [ res_list ]);
	if (!('viewer' in res_forest)) {
		res_forest.viewer = new forestviewer(res_forest.dpy);
		res_forest.viewer.helper = tree_helpers;
		res_forest.viewer.style = "simple";
		res_forest.viewer.variablewidth = true;
		res_forest.viewer.borderwidth = 2;
		res_forest.viewer.nativescroll = true;
		res_forest.viewer.fixed_height = true;
	} else if (res_forest.cur_res == this.num && res_forest.viewer.forest)
		return;
	if ('ssv' in res_forest)
		res_forest.ssv.forest = null;
	res_forest.dpy.overflow = 'auto';
	res_forest.cur_res = this.num;
	res_forest.cur_hit = 0;
	res_forest.viewer.forest = set_tree(
			new forest(res.data.nodes, res.data.root));
	res_forest.nextbutton.visible = res.nodes.length > 1;
	res_forest.prevbutton.visible = res.nodes.length > 1;
	res_forest.buttons_update();
}

function ss_show(evt, num) {
	evt.stopPropagation();

	var res = res_list.results[num];

	switch_to(res_forest, [ res_list ]);
	if (!('ssv' in res_forest)) {
		res_forest.ssv = new synspreadviewer(res_forest.dpy);
		res_forest.showtbrulers = true;
	} else if (res_forest.cur_res == this.num && res_forest.ssv.forest)
		return;
	if ('viewer' in res_forest)
		res_forest.viewer.forest = null;
	res_forest.dpy.overflow = 'hidden';
	res_forest.nextbutton.visible = false;
	res_forest.prevbutton.visible = false;
	res_forest.ssv.forest = new forest(res.data.nodes, res.data.root);
}

/* Try to find a tree in a forest containing all of the nodes that formed
 * the set matching the current query.  In general this may not be possible
 * but we try nevertheless.  */
function set_tree_orig(forest) {
	var nodes = res_list.results[res_forest.cur_res].
			nodes[res_forest.cur_hit];
	var parents = {};
	var fixed = {};
	var current = {};

	var set_current = function(nd) {
		current[nd.nid] = 0;
		if (!('children' in nd))
			return;
		for (var chnum in nd.children[nd.current].child)
			set_current(nd.children[nd.current].child[chnum]);
	}
	set_current(forest.root);

	for (var nid in forest.nodes) {
		var node = forest.nodes[nid];
		if (!('children' in node))
			continue;
		for (var rnum in node.children)
			for (var chnum  in node.children[rnum].child) {
				var subnid = node.children[rnum].
						child[chnum].nid;
				if (!(subnid in parents))
					parents[subnid] = {};
				if (!(nid in parents[subnid]))
					parents[subnid][nid] = {};
				parents[subnid][nid][parseInt(rnum)] = 0;
			}
	}

	/* This code is not always enough, sometimes it would be possible to
	 * find a common tree but the code below won't.  But a better version
	 * would be more costly and complex as far as I can tell.  */
	for (var nnum in nodes) {
		var nid = nodes[nnum];
		while (nid in parents) {
			var p = null;
			if (p == null)
				for (var supnid in parents[nid])
					if (supnid in fixed) {
						p = supnid;
						break;
					}
			if (p == null)
				for (var supnid in parents[nid])
					if (supnid in current) {
						p = supnid;
						break;
					}
			if (p == null)
				for (var supnid in parents[nid])
					if (forest.nodes[supnid].chosen) {
						p = supnid;
						break;
					}
			if (p == null)
				for (var supnid in parents[nid])
					if (forest.nodes[supnid].current ==
							parents[nid][supnid]) {
						p = supnid;
						break;
					}
			if (p == null)
				for (var supnid in parents[nid]) {
					p = supnid;
					break;
				}
			if (p in fixed) {
				/* Either there's nothing to do or there's
				 * nothing that can be done and we give up
				 * for this node */
				forest.nodes[p].current = find_common(
						forest.nodes[p].current,
						parents[nid][p]);
				break;
			}
			fixed[p] = 0;
			forest.nodes[p].current = parents[nid][p];
			nid = p;
		}
	}

	for (var nid in forest.nodes) {
		var node = forest.nodes[nid];
		if (!('current' in node))
			continue;
		if (typeof(node.current) == 'object')
			for (var c in node.current) {
				node.current = c;
				break;
			}
	}

	return forest;
}

function find_common(a, b) {
	if (typeof(a) != 'object')
		return a;
	var r = {}, cnt = 0;
	for (var c in a)
		if (c in b)
			r[c] = cnt ++;
	if (cnt > 1)
		return r;
	if (cnt < 1)
		r = a;
	for (var c in r)
		return c;
}

/* Newer, better */
function set_tree(forest) {
	var nodes = res_list.results[res_forest.cur_res].
			nodes[res_forest.cur_hit];
	var parents = {};
	var score = {};

	for (var nid in forest.nodes) {
		var node = forest.nodes[nid];
		if (!('children' in node))
			continue;
		for (var rnum in node.children)
			for (var chnum  in node.children[rnum].child) {
				var subnid = node.children[rnum].
						child[chnum].nid;
				if (!(subnid in parents))
					parents[subnid] = {};
				parents[subnid][nid + '-' + rnum] = 0;
			}
	}

	for (var nnum in nodes) {
		var done = {};
		var nids = [ nodes[nnum] ];
		while (nids.length) {
			var nid = nids.shift();
			if (nid in done || !(nid in parents))
				continue;
			for (var p in parents[nid]) {
				if (p in done)
					continue;
				done[p] = 0;
				var pn = p.pysplit('-');
				if (!(pn[0] in score))
					score[pn[0]] = {};
				if (!(pn[1] in score[pn[0]]))
					score[pn[0]][pn[1]] = 0;
				score[pn[0]][pn[1]] ++;
				nids.push(pn[0]);
			}
			done[nid] = 0;
		}
	}

	/* There's some space for improvement here as well, for example
	 * when faced with more than one rule with the max score, we could
	 * try to select the one which preserves the biggest number of
	 * nodes visible from the current tree or .chosen nodes.  */
	var set_new = function(nd) {
		if (!('children' in nd) || !(nd.nid in score))
			return;
		var max = 0;
		var maxset;
		for (var n in score[nd.nid])
			if (score[nd.nid][n] > max) {
				max = score[nd.nid][n];
				maxset = {};
				maxset[n] = 0;
			} else if (score[nd.nid][n] == max)
				maxset[n] = 0;
		if (!(nd.current in maxset)) {
			if (nd.chrule in maxset)
				nd.current = nd.chrule;
			else for (var n in maxset) { /* Pick the 1st option */
				nd.current = parseInt(n);
				alert("" + n + " of " + nd.children.length);
				break;
			}
		}
		for (var chnum in nd.children[nd.current].child)
			set_new(nd.children[nd.current].child[chnum]);
	}
	set_new(forest.root);

	return forest;
}

res_forest.buttons_update = function(desel) {
	var res = res_list.results[this.cur_res];

	this.nextbutton.enabled = this.cur_hit < res.nodes.length - 1;
	this.prevbutton.enabled = !!this.cur_hit;
	this.nextbutton.innerHTML = '&gt; (' + (this.cur_hit + 1) + ' z ' +
		res.nodes.length + ')';

	if (desel != undefined) {
		for (var i in res.nodes[desel]) {
			var node = this.viewer.forest.
					nodes[res.nodes[desel][i]];
			delete node.matched;
			if (!('elem' in node))
				continue;
			/* Note: ff >= 3.6? :-( */
			/*node.elem.classList.remove('matched-node');*/
			node.elem.className =
				node.elem.className.replace('matched-node', '');
		}
	}

	for (var i in res.nodes[this.cur_hit]) {
		var node = this.viewer.forest.nodes[res.nodes[this.cur_hit][i]];
		node.matched = true;
		if (!('elem' in node))
			continue;
		/* Note: ff >= 3.6? :-( */
		/*node.elem.classList.add('matched-node');*/
		node.elem.className += ' matched-node';
	}

	/* Try to select the tree containing the nodes matching */
	set_tree(this.viewer.forest);
}

res_forest.nextbutton.onclick = function(evt) {
	if (!res_forest.nextbutton.enabled)
		return;
	res_forest.buttons_update(res_forest.cur_hit ++);
	res_forest.viewer.relayout();
}

res_forest.prevbutton.onclick = function(evt) {
	if (!res_forest.prevbutton.enabled)
		return;
	res_forest.buttons_update(res_forest.cur_hit --);
	res_forest.viewer.relayout();
}

res_list.set_message = function(msg) {
	var mid = document.createElement('div');
	mid.className = 'mid';
	mid.innerHTML = msg;

	res_list.results = [];
	res_list.innerHTML = '';
	res_list.appendChild(mid);
}

function pl_plural(num) {
	num = Math.abs(num);
	if (num == 1)
		return 0;
	num = num % 100;
	var num10 = num % 10;
	return (num10 < 2 || num10 > 4 || (num > 10 && num < 20)) ? 2 : 1;
}

String.prototype.pysplit = function(str, num) {
	var left = this;
	var ret = [];
	if (num == null)
		num = -2;
	while (num -- != 0) {
		var pos = left.indexOf(str);
		if (pos == -1) {
			ret.push(left);
			if (num < 0)
				return ret;
			left = "";
			continue;
		}
		ret.push(left.substr(0, pos));
		left = left.substr(pos + 1);
	}
	ret.push(left);
	return ret;
}

function find_root(nodes, start_symbol) {
	for (var nid in nodes)
		if (nodes[nid].nonterminal &&
				nodes[nid].nonterminal.category ==
				start_symbol) {
			if ('nid' in nodes[nid])
				return nodes[nid].nid;
			return nid;
		}
	throw 'Root not found';
}

function adapt_schema(obj) {
	var ret = {};

	if ('forest' in obj)
		obj = obj.forest;

	if (!('node' in obj))
		throw 'Empty forest';

	if ('nid' in obj.node)
		obj.node = [ obj.node ];

	ret.nodes = {};
	for (var i in obj.node) {
		var node = obj.node[i];
		var tnt;
		ret.nodes[node.nid] = node;
		if (node.terminal) {
			var t = node.terminal;
			if (t.length)
				for (var idx in t)
					if ('category' in t[idx] ||
							'orth' in t[idx] ||
							'f' in t[idx]) {
						node.terminal = t[idx];
						t = t[idx];
						break;
					}
			if ('category' in t || 'orth' in t || 'f' in t)
				tnt = t;
		}
		if (node.nonterminal) {
			var nt = node.nonterminal;
			if (nt.length)
				for (var idx in nt)
					if ('category' in nt[idx] ||
							'orth' in nt[idx] ||
							'f' in nt[idx]) {
						node.nonterminal = nt[idx];
						nt = nt[idx];
						break;
					}
			if ('category' in nt || 'orth' in nt || 'f' in nt)
				tnt = nt;
		}
		if ('#text' in tnt)
			delete tnt['#text'];
		if (!('f' in tnt) || !(('type' in tnt.f) || tnt.f.length))
			continue;
		var f = tnt.f;
		delete tnt.f;
		if (!f.length)
			f = [ f ];
		if ('#text' in f)
			delete t['#text'];
		for (var idx in f) {
			if (!('type' in f[idx]) || !('#text' in f[idx]))
				continue;
			tnt[f[idx].type] = f[idx]['#text'];
		}
	}

	ret.root = find_root(ret.nodes, obj.startnode['#text']);

	var terminals = {};

	for (var nid in ret.nodes) {
		var node = ret.nodes[nid];
		if (!node.terminal)
			continue;
		terminals[node.from] = node;
	}

	ret.text = '';
	ret.frompos = {};
	ret.topos = {};
	var last = 0;

	while (last in terminals) {
		var term = terminals[last];
		if (!term.terminal.nps)
			ret.text += ' ';
		ret.frompos[term.from] = ret.text.length;
		ret.text += term.terminal.orth;
		ret.topos[term.to] = ret.text.length;
		last = term.to;
	}

	for (var nid in ret.nodes) {
		var node = ret.nodes[nid];
		if (node.terminal)
			continue;
		if (!('children' in node))
			node.children = [];
		else if ('child' in node.children)
			node.children = [ node.children ];
		for (var rulenum in node.children) {
			var r = node.children[rulenum];
			var chlist = r.child;
			var heads = [];
			r.child = [];
			var check_ch = function(elem) {
				if (typeof(elem) == 'number')
					r.child.push(elem);
				else if (typeof(elem) == 'string')
					r.child.push(parseInt(elem));
				else if (typeof(elem) == 'boolean')
					r.child.push(elem);
				else if (typeof(elem) == 'object' &&
						'nid' in elem) {
					if ('' + elem.head == 'true')
						heads.push(r.child.length);
					r.child.push(elem.nid);
				} else
					return false;
				return true;
			}
			if (!check_ch(chlist))
				for (var chnum in chlist)
					check_ch(chlist[chnum]);
			if (heads.length)
				r.heads = heads;
			if (!('current' in node) && r.chosen)
				node.current = node.chrule = parseInt(rulenum);
		}
	}

	return ret;
}

var wait = "<img border=\"0\" src=\"www/wait.gif\" alt=\"...\" />";
var wait_small = "<img border=\"0\" src=\"www/wait.gif\" alt=\"...\" style=\"" +
	"height: 1em;\" />";

function jsonp_eval(jsonp) {
	var ret;
	var c = function(value) { return value; }
	var False = false;
	var True = true;
	eval(jsonp);
	return ret;
}

/*
 * File loader
 * (TODO: Try to support JSON-P)
 */
var cq = [];
function request_send(treeurl, cb, err_cb, xml, data) {
	var http_request;
	var mime = xml ? "text/xml" : "text/plain";

	if (window.XMLHttpRequest) { /* Mozilla, webkit,... */
		http_request = new XMLHttpRequest();
		if (http_request.overrideMimeType)
			http_request.overrideMimeType(mime);
	} else if (window.ActiveXObject) { /* IE */
		try {
			http_request = new ActiveXObject("Msxml2.XMLHTTP");
		} catch (e) {
			try {
				http_request =
					new ActiveXObject("Microsoft.XMLHTTP");
			} catch (e) {}
		}
	}
	if (!http_request) {
		alert("I couldn\'t make no XMLHttp object :-(");
		return false;
	}

	http_request.onreadystatechange = function() {
		if (http_request.readyState != 4)
			return;

		if (http_request.status == 200) {
			var resp;
			try {
				var resp = xml ?
					parse_xml(http_request.responseXML) :
					jsonp_eval(http_request.responseText);
			} catch (e) {
				err_cb(e);
				return;
			}

			if (data)
				cb(resp, data);
			else
				cb(resp);
			return;
		}

		/* TODO: handle the error (retry? display error
		 * in a non-obtrusive text field?) */
		/* TODO: or fall back to JSON-P immediately? */

		err_cb("Error " + http_request.status +
			" reading the forest description");

		if (http_request.status == 0) {
			/* TODO: switch to JSON-P mode */
		}
	}
	http_request.open('GET', treeurl, true);
	http_request.send(null);

	return http_request;
}]]></script>
</body>
</html>
